Index: src/main/java/it/polimi/it/galaxytrucker/managers/Model.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/Model.java b/src/main/java/it/polimi/it/galaxytrucker/managers/Model.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/Model.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,37 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import java.util.List;
-import java.util.Set;
-import java.util.UUID;
-
-import it.polimi.it.galaxytrucker.aventurecard.AdventureDeck;
-import it.polimi.it.galaxytrucker.componenttiles.ComponentTile;
-import it.polimi.it.galaxytrucker.design.statePattern.State;;
-
-public interface Model {
-    //GETTER
-    public State getCurrentState();
-    public Integer getLevel();
-    public Integer getNumberOfPlayers();
-    public List<Player> getPlayers();
-    public Player getPlayerByID(UUID id);
-    public boolean allPlayersConnected();
-    public ShipManager getPlayerShip(UUID id);
-    public Set<Player> getPlayersWithIllegalShips();
-    public Set<ComponentTile> getComponentTiles();
-    public FlightBoardState getFlightBoard();
-    public AdventureDeck getAdventureDeck();
-
-    //SETTER
-    public void changeState(State nextState);
-    public void setLevel(int level);
-    public void setNumberOfPlayers(int numberOfPlayers);
-    public UUID addPlayer(String name);
-    public void removePlayer(UUID id);
-
-    //ACTIONS
-    public ComponentTile drawComponentTile();
-    public void placeComponentTile(UUID playerID, ComponentTile component, int row, int column);
-    public void rotateComponentTile(UUID playerID, int row, int column);
-    public void finishBuilding(UUID playerID);
-}
Index: src/main/java/it/polimi/it/galaxytrucker/managers/ShipBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/ShipBoard.java b/src/main/java/it/polimi/it/galaxytrucker/managers/ShipBoard.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/ShipBoard.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,485 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import it.polimi.it.galaxytrucker.componenttiles.*;
-import it.polimi.it.galaxytrucker.exceptions.IllegalComponentPositionException;
-
-import java.util.ArrayList;
-import java.util.Set;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.List;
-import java.util.Optional;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-
-/**
- * The {@code ShipBoard} class represents the grid-based structure of a spaceship 
- * in the Galaxy Trucker game. It manages the placement, retrieval, and removal 
- * of components on the ship, ensuring structural integrity and connectivity.
- * 
- * <p>This class includes functionalities such as:</p>
- * <ul>
- *     <li>Defining ship boundaries based on different levels.</li>
- *     <li>Adding and removing components.</li>
- *     <li>Identifying and managing connected components.</li>
- *     <li>Checking exposed connectors for connectivity validation.</li>
- * </ul>
- * 
- * <p>The ship is represented as a matrix ({@code tileMatrix}) where each cell 
- * contains an {@code Optional<ComponentTile>}, indicating the presence or absence 
- * of a component.</p>
- * 
- * <p>Example of usage:</p>
- * <pre>
- *     ShipBoard ship = new ShipBoard();
- *     ship.setShipBounds(1); // Initialize ship boundaries for level 1
- *     ship.addComponentTile(2, 3, new EngineModule());
- * </pre>
- * <p>Example of usage:</p>
- * <pre>
- *     ShipBoard ship = new ShipBoard(1); // Create and initialize ship boundaries for level 1
- *     ship.addComponentTile(2, 3, new EngineModule());
- * </pre>
- * 
- * @author Stefano Carletto
- * @version 1.2
- */
-public class ShipBoard {
-    private List<List<Optional<ComponentTile>>> tileMatrix;
-    private Map<Class<? extends ComponentTile>, Set<List<Integer>>> componentTilesPosition;
-
-    /**
-     * Initializes a new {@code ShipBoard} instance, representing the ship's component grid.
-     * The board is structured to accommodate ship components and maintain their positions.
-     *
-     * <p>Upon creation, the board is empty, and no components are placed.</p>
-     */
-    public ShipBoard() {
-        final int ROWS = ShipManager.getRows();
-        final int COLUMNS = ShipManager.getColumns();
-
-        this.tileMatrix = IntStream.range(0, ROWS)
-            .mapToObj(_ -> IntStream.range(0, COLUMNS)
-                .mapToObj(_ -> Optional.<ComponentTile>empty())
-                .collect(Collectors.toList())
-            )
-            .collect(Collectors.toList());
-
-        this.componentTilesPosition = new HashMap<>();
-    }
-
-    /**
-     * Initializes a new {@code ShipBoard} instance for a specified ship level.
-     * The board is structured to accommodate ship components and automatically 
-     * applies the appropriate structural boundaries based on the given level.
-     *
-     * <p>Upon creation, the board is empty except for predefined structural constraints {@link OutOfBoundsTile} and the default {@link CentralCabin}.</p>
-     *
-     * @param level The level of the ship (e.g., 1 or 2), determining its valid structure.
-     */
-    public ShipBoard(int level) {
-        final int COLUMNS = 7;
-        final int ROWS = 5;
-
-        this.tileMatrix = IntStream.range(0, ROWS)
-            .mapToObj(_ -> IntStream.range(0, COLUMNS)
-                .mapToObj(_ -> Optional.<ComponentTile>empty())
-                .collect(Collectors.toList())
-            )
-            .collect(Collectors.toList());
-
-        this.componentTilesPosition = new HashMap<>();
-        this.setShipBounds(level);
-    }
-
-    /**
-     * Determines whether a given position (row, column) is outside the valid ship structure
-     * based on the specified level.
-     *
-     * @param level  The level of the ship (e.g., 1 or 2).
-     * @param row    The row index of the position to check.
-     * @param column The column index of the position to check.
-     * @return {@code true} if the position is outside the ship structure, otherwise {@code false}.
-     */
-    private boolean isOutsideTheShip(int level, int row, int column) {
-        switch (level) {
-            case 1:
-                return switch (row) {
-                    case 0 -> column != 3;
-                    case 1 -> column != 2 && column != 3 && column != 4;
-                    case 2 -> column < 1 || column > 5;
-                    case 3 -> column < 1 || column > 5;
-                    case 4 -> column < 1 || column > 5 || column == 3;
-                    default -> false;
-                };
-            case 2:
-                return switch (row) {
-                    case 0 -> column != 2 && column != 4;
-                    case 1 -> column < 1 || column > 5;
-                    case 4 -> column == 3;
-                    default -> false;
-                };
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Retrieves the entire board as a matrix of component tiles.
-     *
-     * @return A {@code List<List<Optional<ComponentTile>>>} representing the board.
-     *         Each inner list corresponds to a row, and each {@code Optional<ComponentTile>} 
-     *         represents a cell that may contain a component or be empty.
-     */
-    public List<List<Optional<ComponentTile>>> getBoard() {
-        return this.tileMatrix;
-    }
-
-    /**
-     * Retrieves the component located at the specified position on the board.
-     *
-     * @param row    The row index of the component.
-     * @param column The column index of the component.
-     * @return An {@code Optional<ComponentTile>} containing the component if present,
-     *         or {@code Optional.empty()} if the cell is empty.
-     * @throws IndexOutOfBoundsException If {@code row} or {@code column} are out of bounds.
-     */
-    public Optional<ComponentTile> getComponent(int row, int column) {
-        return this.tileMatrix.get(row).get(column);
-    }
-
-    /**
-     * Retrieves all unique component types currently placed on the ship.
-     *
-     * @return A set of classes representing the different types of components present on the board.
-     */
-    public Set<Class<? extends ComponentTile>> getAllComponentsTypes() {
-        return this.componentTilesPosition.keySet();
-    }
-
-    /**
-     * Retrieves all positions of components of the specified type on the board.
-     *
-     * @param componentType The class type of the component to search for.
-     * @return A {@code Set<List<Integer>>} containing the coordinates of all components 
-     *         of the given type, where each coordinate is represented as {@code List<Integer> [row, column]}.
-     *         Returns {@code null} if the component type is not found.
-     */
-    public Set<List<Integer>> getAllComponentsPositionOfType(Class<? extends ComponentTile> componentType) {
-        return this.componentTilesPosition.get(componentType);
-    }
-
-    /**
-     * Retrieves the neighboring components of the specified position on the board.
-     * The neighbors are returned in the following order: 
-     * <ul>
-     *   <li>Upper component</li>
-     *   <li>Right component</li>
-     *   <li>Lower component</li>
-     *   <li>Left component</li>
-     * </ul>
-     *
-     * @param row    The row index of the target component.
-     * @param column The column index of the target component.
-     * @return A {@code List<Optional<ComponentTile>>} containing the neighboring components.
-     *         Each element in the list is {@code Optional.empty()} if the corresponding neighbor does not exist.
-     */
-    public List<Optional<ComponentTile>> getNeighbourComponents(int row, int column) {
-        List<Optional<ComponentTile>> neighbours = new ArrayList<>();
-        //top component
-        neighbours.add(row - 1 < 0 ? Optional.<ComponentTile>empty() : this.getComponent(row - 1, column));
-        //right component
-        neighbours.add(column + 1 >= this.tileMatrix.get(row).size() ? Optional.<ComponentTile>empty() : this.getComponent(row, column + 1));
-        //down component
-        neighbours.add(row + 1 >= this.tileMatrix.size() ? Optional.<ComponentTile>empty() : this.getComponent(row + 1, column));
-        //left component
-        neighbours.add(column - 1 < 0 ? Optional.<ComponentTile>empty() : this.getComponent(row, column - 1));
-        return neighbours;
-    }
-
-    /**
-     * Recursively identifies and collects all connected components in a ship's grid,
-     * starting from a specified position. This method performs a depth-first search (DFS) 
-     * to explore all adjacent components that are part of the same connected structure.
-     *
-     * <p>The method stops under the following conditions:</p>
-     * <ul>
-     *     <li>If the specified position is outside the grid boundaries.</li>
-     *     <li>If the component at the specified position is either empty or marked as an {@code OutOfBoundsTile},
-     *         indicating an invalid or unoccupied position.</li>
-     *     <li>If the component at the specified position has already been visited and added to the branch.</li>
-     * </ul>
-     *
-     * <p>Once a valid component is found, it is added to the {@code branch} set, 
-     * and the method recursively explores its four neighboring components (top, right, bottom, left)
-     * to continue the search.</p>
-     *
-     * @param row    The row index of the component to start the search from.
-     * @param column The column index of the component to start the search from.
-     * @param branch A set that stores coordinate pairs {@code (row, column)} representing all 
-     *               connected components that belong to the same structure.
-     */
-    public void getBranchOfComponent(int row, int column, Set<List<Integer>> branch) {
-        //check boundaries of matrix
-        if (row < 0 || row >= this.tileMatrix.size() || column < 0 || column >= this.tileMatrix.get(row).size()) {
-            return;
-        }
-        //check if component is empty or outside the ship
-        if (this.getComponent(row, column).isEmpty() || this.getComponent(row, column).get().getClass() == OutOfBoundsTile.class) {
-            return;
-        }
-        //check if component is already added
-        if (branch.contains(List.of(row, column))) {
-            return;
-        }
-
-        //if all test passed, component is connected to the branch, thus added
-        branch.add(List.of(row, column));
-
-        //calls all 4 directions
-        //top component
-        getBranchOfComponent(row - 1, column, branch);
-        //right component
-        getBranchOfComponent(row, column + 1, branch);
-        //down component
-        getBranchOfComponent(row + 1, column, branch);
-        //left component
-        getBranchOfComponent(row, column - 1, branch);
-    }
-
-    /**
-     * Identifies and groups all disconnected branches of connected components within the ship's grid.
-     * A branch is defined as a set of connected components that form a continuous structure.
-     *
-     * <p>This method iterates through the grid and performs a depth-first search (DFS) to find 
-     * all disconnected clusters of components. Each unique branch is stored as a set of coordinate 
-     * pairs representing the connected components.</p>
-     *
-     * <p>The method follows these steps:</p>
-     * <ul>
-     *     <li>Iterate through all positions in the {@code tileMatrix}.</li>
-     *     <li>Ignore empty tiles or tiles marked as {@code OutOfBoundsTile}, as they are not part of a branch.</li>
-     *     <li>If a component has not been visited, perform a recursive search using 
-     *         {@link #getBranchOfComponent(int, int, Set)} to collect all connected components.</li>
-     *     <li>Add the discovered branch to the set of all branches.</li>
-     * </ul>
-     *
-     * <p>Each branch is represented as a {@code Set<List<Integer>>}, where each list contains 
-     * two integers: {@code (row, column)}.</p>
-     *
-     * @return A list of disconnected branches, where each branch is a set of coordinate pairs 
-     *         representing connected components.
-     */
-    public List<Set<List<Integer>>> getDisconnectedBranches() {
-        List<Set<List<Integer>>> branches = new ArrayList<>();
-        Set<List<Integer>> visitedComponents = new HashSet<>();
-
-        for (int i = 0; i < this.tileMatrix.size(); i++) {
-            for (int j = 0; j < this.tileMatrix.get(i).size(); j++) {
-                if (this.getComponent(i, j).isEmpty()) {
-                    continue;
-                }
-                if (this.getComponent(i, j).get().getClass().equals(OutOfBoundsTile.class)) {
-                    continue;
-                }
-
-                List<Integer> component = List.of(i, j);
-
-                if (!visitedComponents.contains(component)) {
-                    Set<List<Integer>> newBranch = new HashSet<>();
-
-                    this.getBranchOfComponent(i, j, newBranch);
-                    visitedComponents.addAll(newBranch);
-                    branches.add(newBranch);
-                }
-            }
-        }
-        return branches;
-    }
-
-    /**
-     * Sets the boundaries of the ship by marking positions outside the valid ship structure 
-     * with {@code OutOfBoundsTile} components based on the specified level.
-     * Also initializes the board placing a {@code CentralCabin} at the center of the ship
-     *
-     * @param level The level of the ship (e.g., 1 or 2).
-     */
-    public void setShipBounds(int level) {
-        for (int i = 0; i < this.tileMatrix.size(); i++) {
-            for (int j = 0; j < this.tileMatrix.get(i).size(); j++) {
-                if (isOutsideTheShip(level, i, j)) {
-                    try {
-                        this.addComponentTile(i, j, new OutOfBoundsTile());
-                    } catch (IllegalComponentPositionException e) {
-                        e.printStackTrace();
-                    }
-                }
-            }
-        }
-        final int CENTRALCABINROW = 2;
-        final int CENTRALCABINCOLUMN = 3;
-        
-        try {
-            // PER QUANDO AGGIUNGIAMO GRAFICHE: blu - 33, verde - 34, rosso - 52, giallo - 61
-            this.addComponentTile(CENTRALCABINROW, CENTRALCABINCOLUMN, new CentralCabin(List.of(TileEdge.UNIVERSAL, TileEdge.UNIVERSAL, TileEdge.UNIVERSAL, TileEdge.UNIVERSAL)));
-        } catch (IllegalComponentPositionException e) {
-            e.printStackTrace();
-        }
-    }
-
-    /**
-     * Adds a component to the specified position on the board.
-     *
-     * @param row       The row index where the component should be placed.
-     * @param column    The column index where the component should be placed.
-     * @param component The {@code ComponentTile} to be added.
-     * @throws IndexOutOfBoundsException If the specified row or column is out of the ship's bounds.
-     * @throws IllegalComponentPositionException If a component is already present at the specified position or if the specified position is outside the ship.
-     */
-    public void addComponentTile(int row, int column, ComponentTile component) throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        if (this.getComponent(row, column).isPresent() && this.getComponent(row, column).get().getClass().equals(OutOfBoundsTile.class)) {
-            throw new IllegalComponentPositionException("You cannot place a component outside the ship");
-        }
-        if (this.getComponent(row, column).isPresent()) throw new IllegalComponentPositionException("You have already placed a component here");
-
-        this.tileMatrix.get(row).set(column, Optional.of(component));
-        this.componentTilesPosition.putIfAbsent(component.getClass(), new HashSet<>());
-        this.componentTilesPosition.get(component.getClass()).add(List.of(row, column));
-    }
-
-    /**
-     * Removes the component from the specified position on the board.
-     *
-     * @param row    The row index of the component to be removed.
-     * @param column The column index of the component to be removed.
-     * @return The removed component
-     * @throws IndexOutOfBoundsException If the specified row or column is out of the ship's bounds.
-     * @throws IllegalComponentPositionException If there is no component at the specified position.
-     */
-    public ComponentTile removeComponentTile(int row, int column) throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        if (this.getComponent(row, column).isEmpty() || 
-            (this.getComponent(row, column).isPresent() && this.getComponent(row, column).get().getClass().equals(OutOfBoundsTile.class))) {
-            throw new IllegalComponentPositionException("There is no element here");
-        }
-
-        ComponentTile component = this.getComponent(row, column).get();
-        Class<? extends ComponentTile> componentType = component.getClass();
-
-        Set<List<Integer>> positions = this.componentTilesPosition.get(componentType);
-
-        this.tileMatrix.get(row).set(column, Optional.<ComponentTile>empty());
-
-        positions.removeIf(coord -> coord.equals(List.of(row, column)));
-        if (positions.isEmpty()) {
-            this.componentTilesPosition.remove(componentType);
-        }
-
-        return component;
-    }
-
-    /**
-     * Removes all components in a given branch from the ship's grid.
-     * This method iterates through the provided set of coordinates and removes 
-     * each corresponding component by calling {@link #removeComponentTile(int, int)}.
-     *
-     * <p>If any coordinate in the branch refers to an invalid position or an unremovable component, 
-     * the method will throw an {@code IllegalComponentPositionException}.</p>
-     *
-     * @param branch A set of coordinate pairs {@code (row, column)} representing the components 
-     *               to be removed.
-     * @return A set containing all removed components
-     * @throws IndexOutOfBoundsException If the specified row or column is out of the ship's bounds.
-     * @throws IllegalComponentPositionException If the removal of a component at any given coordinate 
-     *         is not allowed due to game rules or invalid positioning.
-     */
-    public Set<ComponentTile> removeBranch(Set<List<Integer>> branch) throws IllegalComponentPositionException {
-        Set<ComponentTile> removedComponents = new HashSet<>();
-        for (List<Integer> coord : branch) {
-            ComponentTile removed = this.removeComponentTile(coord.get(0), coord.get(1));
-            removedComponents.add(removed);
-        }
-
-        return removedComponents;
-    }
-
-    /**
-     * Counts the number of exposed connectors for a given component at the specified position.
-     * A connector is considered exposed if it is of type {@code SINGLE}, {@code DOUBLE}, or {@code UNIVERSAL}
-     * and there is no adjacent component in that direction.
-     *
-     * @param row    The row index of the component.
-     * @param column The column index of the component.
-     * @return The number of exposed connectors for the component at the given position. If the position is empty or outside the board, returns 0
-     */
-    public int countExposedConnectors(int row, int column) {
-        Optional<ComponentTile> component = this.getComponent(row, column);
-        if (component.isEmpty() || 
-            (component.isPresent() && component.get().getClass().equals(OutOfBoundsTile.class))) {
-            return 0;
-        }
-        List<TileEdge> edges = component.get().getTileEdges();
-
-        List<Optional<ComponentTile>> neighbours = this.getNeighbourComponents(row, column);
-
-        int exposedConnectors = 0;
-
-        for (int i = 0; i < edges.size(); i++) {
-            if (neighbours.get(i).isEmpty() || neighbours.get(i).get().getClass().equals(OutOfBoundsTile.class)) {
-                if (edges.get(i) == TileEdge.SINGLE || edges.get(i) == TileEdge.DOUBLE || edges.get(i) == TileEdge.UNIVERSAL) {
-                    exposedConnectors++;
-                }
-            }
-        }
-        return exposedConnectors;
-    }
-
-    //? TESTING ONLY
-    public void printBoard() {
-        for (int i = 0; i < this.tileMatrix.size(); i++) {
-            for (int j = 0; j < this.tileMatrix.get(i).size(); j++) {
-                this.getComponent(i, j).ifPresentOrElse(component -> {
-                    if (component.getClass().equals(OutOfBoundsTile.class)) {
-                        System.out.print("   ");
-                    } else {
-                        System.out.print("[x]");
-                    }
-                }, () -> System.out.print("[ ]"));
-            }
-            System.out.println();
-        }
-        System.out.println();
-    }
-
-    //?TEST ONLY
-    public void printBranch(int level, Set<List<Integer>> branch) {
-        ShipBoard branchBoard = new ShipBoard();
-        branchBoard.setShipBounds(level);
-        try {
-            branchBoard.removeComponentTile(2, 3);
-        } catch (IllegalComponentPositionException e) {
-            e.printStackTrace();
-        }
-        for (List<Integer> coord : branch) {
-            try {
-                branchBoard.addComponentTile(coord.get(0), coord.get(1), new SingleCannon(List.of(TileEdge.SINGLE, TileEdge.SINGLE, TileEdge.SINGLE, TileEdge.SINGLE)));
-            } catch (IllegalComponentPositionException e) {
-                e.printStackTrace();
-            }
-        }
-
-        for (int i = 0; i < branchBoard.getBoard().size(); i++) {
-            for (int j = 0; j < branchBoard.getBoard().get(i).size(); j++) {
-                branchBoard.getComponent(i, j).ifPresentOrElse(component -> {
-                    if (component.getClass().equals(OutOfBoundsTile.class)) {
-                        System.out.print("   ");
-                    } else {
-                        System.out.print("[x]");
-                    }
-                }, () -> System.out.print("[ ]"));
-            }
-            System.out.println();
-        }
-        System.out.println();
-    }
-}
Index: src/main/java/it/polimi/it/galaxytrucker/managers/GameManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/GameManager.java b/src/main/java/it/polimi/it/galaxytrucker/managers/GameManager.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/GameManager.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,226 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.*;
-import java.util.stream.Collectors;
-
-import com.fasterxml.jackson.databind.JsonNode;
-import it.polimi.it.galaxytrucker.aventurecard.AdventureDeck;
-import it.polimi.it.galaxytrucker.componenttiles.*;
-import it.polimi.it.galaxytrucker.design.statePattern.StateMachine;
-import it.polimi.it.galaxytrucker.exceptions.IllegalComponentPositionException;
-import it.polimi.it.galaxytrucker.exceptions.InvalidActionException;
-import it.polimi.it.galaxytrucker.exceptions.NotFoundException;
-import it.polimi.it.galaxytrucker.gameStates.StartState;
-import it.polimi.it.galaxytrucker.json.Json;
-import it.polimi.it.galaxytrucker.utility.Color;;
-
-public class GameManager extends StateMachine implements Model {
-    private Integer level;
-    private Integer numberOfPlayers;
-    private List<Player> players;
-    private Set<ComponentTile> components;
-    private FlightBoardState flightBoard;
-    private AdventureDeck adventureDeck;
-
-    public GameManager() {
-        start(new StartState());
-    }
-
-    @Override
-    public Integer getLevel() {
-        return this.level;
-    }
-
-    @Override
-    public Integer getNumberOfPlayers() {
-        return this.numberOfPlayers;
-    }
-
-    @Override
-    public List<Player> getPlayers() {
-        return this.players;
-    }
-
-    @Override
-    public Player getPlayerByID(UUID id) {
-        return this.players.stream()
-            .filter(player -> player.getPlayerID().equals(id))
-            .findFirst()
-            .orElse(null);
-    }
-
-    @Override
-    public boolean allPlayersConnected() {
-        return this.players.size() == this.numberOfPlayers ? true : false;
-    }
-
-    @Override
-    public ShipManager getPlayerShip(UUID id) {
-        return Optional.ofNullable(this.getPlayerByID(id).getShipManager())
-            .orElse(null);
-    }
-
-    @Override
-    public Set<Player> getPlayersWithIllegalShips() {
-        return this.players.stream()
-            .filter(player -> !player.getShipManager().isShipLegal())
-            .collect(Collectors.toSet());
-    }
-
-    @Override
-    public Set<ComponentTile> getComponentTiles() {
-        return this.components;
-    }
-
-    @Override
-    public FlightBoardState getFlightBoard() {
-        return this.flightBoard;
-    }
-
-    @Override
-    public AdventureDeck getAdventureDeck() {
-        return this.adventureDeck;
-    }
-
-    @Override
-    public void setLevel(int level) {
-        this.level = level;
-
-        updateState();
-    }
-
-    @Override
-    public void setNumberOfPlayers(int numberOfPlayers) {
-        this.numberOfPlayers = numberOfPlayers;
-
-        updateState();
-    }
-
-    @Override
-    public UUID addPlayer(String name) throws InvalidActionException {
-        ensureNameIsUnique(name);
-        
-        Color playerColor = findFirstAvailableColor();
-
-        Player newPlayer = new Player(UUID.randomUUID(), name, 0, playerColor);
-        players.add(newPlayer);
-
-        updateState();
-        
-        return newPlayer.getPlayerID();
-    }
-
-    private void ensureNameIsUnique(String name) throws InvalidActionException {
-        boolean isTaken = this.players.stream()
-            .anyMatch(player -> player.getPlayerName().equals(name));
-        
-        if (isTaken) {
-            throw new InvalidActionException("Another player named " + name + " is already playing");
-        }
-    }
-
-    private Color findFirstAvailableColor() throws InvalidActionException {
-        return Arrays.stream(Color.values())
-            .filter(color -> players.stream()
-                .noneMatch(player -> player.getColor().equals(color)))
-            .findFirst()
-            .orElseThrow(() -> new InvalidActionException("No available color"));
-    }
-
-    @Override
-    public void removePlayer(UUID id) throws NotFoundException {
-        Player playerToRemove = this.players.stream()
-            .filter(player -> player.getPlayerID().equals(id))
-            .findFirst()
-            .orElseThrow(() -> new NotFoundException("Cannot find the player"));
-
-        this.players.remove(playerToRemove);
-    }
-
-    public void initializeGameSpecifics() {
-        this.players = new ArrayList<>(this.numberOfPlayers);
-    }
-
-    public void initializeShips() {
-        for (Player player : players) {
-            player.createShip(this.level);
-        }
-    }
-
-    public void initializeFlightBoard() {
-        this.flightBoard = new FlightBoardState(this.level);
-    }
-
-    public void initializeComponentTiles() {
-        File file = new File("src/main/resources/it/polimi/it/galaxytrucker/json/componenttiles.json");
-
-        try {
-            JsonNode node = Json.parse(file);
-            components = Json.fromJsonSet(node, ComponentTile.class);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void initializeAdventureDeck() {
-        //TODO from JSON file
-    }
-
-    public ComponentTile drawComponentTile() throws InvalidActionException {
-        if (components.isEmpty()) {
-            throw new InvalidActionException("There are no components left");
-        }
-
-        int randomIndex = getRandomIndex(components.size());
-        return removeComponentTileAtIndex(randomIndex);
-    }
-
-    private int getRandomIndex(int upperBoundExclusive) {
-        return new Random().nextInt(upperBoundExclusive);
-    }
-
-    private ComponentTile removeComponentTileAtIndex(int index) throws IndexOutOfBoundsException {
-        Iterator<ComponentTile> iterator = components.iterator();
-        int currentIndex = 0;
-    
-        while (iterator.hasNext()) {
-            ComponentTile tile = iterator.next();
-
-            if (currentIndex++ == index) {
-                iterator.remove();
-                return tile;
-            }
-        }
-    
-        throw new IndexOutOfBoundsException("Index " + index + " is out of bounds");
-    }
-
-    public void placeComponentTile(UUID playerID, ComponentTile component, int row, int column) throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        Player player = this.getPlayerByID(playerID);
-        ShipManager ship = player.getShipManager();
-
-        ship.addComponentTile(row, column, component);
-    }
-
-    public void rotateComponentTile(UUID playerID, int row, int column) throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        Player player = getPlayerByID(playerID);
-        ShipManager ship = player.getShipManager();
-
-        if (ship.isOutside(row, column)) {
-            throw new IllegalComponentPositionException("Position (" + row + ", " + column + ") is outside the ship.");
-        }
-
-        ship.getComponent(row, column).ifPresentOrElse(
-            ComponentTile::rotate,
-            () -> {
-                throw new IllegalComponentPositionException("No component found at position (" + row + ", " + column + ").");
-            }
-        );
-    }
-
-    public void finishBuilding(UUID playerID) {
-        updateState();
-    }
-}
Index: src/main/java/it/polimi/it/galaxytrucker/managers/ShipManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/ShipManager.java b/src/main/java/it/polimi/it/galaxytrucker/managers/ShipManager.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/ShipManager.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,1504 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import it.polimi.it.galaxytrucker.componenttiles.ComponentTile;
-import it.polimi.it.galaxytrucker.componenttiles.DoubleCannon;
-import it.polimi.it.galaxytrucker.componenttiles.DoubleEngine;
-import it.polimi.it.galaxytrucker.componenttiles.EnergyConsumer;
-import it.polimi.it.galaxytrucker.componenttiles.LifeSupport;
-import it.polimi.it.galaxytrucker.componenttiles.OutOfBoundsTile;
-import it.polimi.it.galaxytrucker.componenttiles.SingleCannon;
-import it.polimi.it.galaxytrucker.componenttiles.SingleEngine;
-import it.polimi.it.galaxytrucker.componenttiles.SpecialCargoHold;
-import it.polimi.it.galaxytrucker.componenttiles.TileEdge;
-import it.polimi.it.galaxytrucker.crewmates.Alien;
-import it.polimi.it.galaxytrucker.crewmates.Crewmate;
-import it.polimi.it.galaxytrucker.crewmates.Human;
-import it.polimi.it.galaxytrucker.componenttiles.BatteryComponent;
-import it.polimi.it.galaxytrucker.componenttiles.CabinModule;
-import it.polimi.it.galaxytrucker.componenttiles.CargoHold;
-import it.polimi.it.galaxytrucker.componenttiles.CentralCabin;
-import it.polimi.it.galaxytrucker.utility.Cargo;
-import it.polimi.it.galaxytrucker.utility.Color;
-import it.polimi.it.galaxytrucker.utility.AlienType;
-import it.polimi.it.galaxytrucker.exceptions.IllegalComponentPositionException;
-import it.polimi.it.galaxytrucker.exceptions.InvalidActionException;
-
-import java.util.Set;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Optional;
-import java.util.OptionalInt;
-
-/**
- * The {@code ShipManager} class is responsible for managing the components and
- * crew
- * of a spaceship in the Galaxy Trucker game. It provides high-level operations
- * for
- * adding, removing, and managing ship components while ensuring game rules and
- * constraints are met.
- *
- * <p>
- * This class acts as a controller that interacts with the underlying
- * {@link ShipBoard},
- * translating board coordinates into tile matrix coordinates, handling the
- * placement and
- * removal of components, and enforcing constraints related to crew, aliens,
- * engines, and cargo.
- * </p>
- *
- * <p>
- * Main functionalities include:
- * </p>
- * <ul>
- * <li>Managing the ship's grid layout based on game level.</li>
- * <li>Adding and removing components while ensuring legal placement.</li>
- * <li>Handling crew members, including human and alien placement with life
- * support checks.</li>
- * <li>Tracking energy sources such as batteries.</li>
- * <li>Calculating ship attributes such as firepower and engine power.</li>
- * </ul>
- *
- * <p>
- * The ship is represented internally by an instance of {@link ShipBoard}, which
- * maintains the actual grid structure and components.
- * </p>
- *
- * <h2>Example of usage:</h2>
- * 
- * <pre>
- * ShipManager manager = new ShipManager(1); // Initialize for level 1
- * manager.addComponentTile(2, 3, new EngineModule());
- * manager.addCrewmate(2, 3, new Human());
- * boolean isValid = manager.isShipLegal();
- * </pre>
- *
- * @author Stefano Carletto
- * @version 1.3
- */
-public class ShipManager {
-    private ShipBoard ship;
-    private List<ComponentTile> discardedTile;
-    private HashMap<AlienType, Boolean> hasAlien;
-    static private final int ROWS = 5;
-    static private final int COLUMNS = 7;
-    static private final int STARTOFBOARDROWS = 5;
-    static private final int STARTOFBOARDCOLUMNS = 4;
-
-    public ShipManager(int level) {
-        this.ship = new ShipBoard(level);
-        discardedTile = new ArrayList<>(2);
-        this.hasAlien = new HashMap<>();
-    }
-
-    /**
-     * Converts the given row and/or column from board coordinates to tile matrix
-     * coordinates.
-     *
-     * <p>
-     * This method adjusts the given row and column indices by subtracting the
-     * board's
-     * starting indices, as defined in {@link ShipManager#STARTOFBOARDROWS} and
-     * {@link ShipManager#STARTOFBOARDCOLUMNS}, to map them correctly within the
-     * ship's tile matrix.
-     * </p>
-     *
-     * <p>
-     * If a row or column index is out of bounds, an
-     * {@link IndexOutOfBoundsException} is thrown.
-     * </p>
-     *
-     * @param row    An {@link Optional} containing the row index to convert, or
-     *               empty if not provided.
-     * @param column An {@link Optional} containing the column index to convert, or
-     *               empty if not provided.
-     * @return A list containing two {@link Optional} elements: the converted row
-     *         and column indices.
-     *
-     * @throws IndexOutOfBoundsException If the row or column is out of the ship's
-     *                                   tile matrix bounds.
-     */
-    private List<Optional<Integer>> toTileMatrixCoord(Optional<Integer> row, Optional<Integer> column)
-            throws IndexOutOfBoundsException {
-        Optional<Integer> tileMatrixRow = row.map(r -> r - ShipManager.STARTOFBOARDROWS);
-        Optional<Integer> tileMatrixColumn = column.map(c -> c - ShipManager.STARTOFBOARDCOLUMNS);
-
-        // checking matrix bound
-        tileMatrixRow.ifPresent(r -> {
-            if (r < 0 || r >= ShipManager.ROWS) {
-                throw new IndexOutOfBoundsException("The specified row is out of the board's bounds.");
-            }
-        });
-        tileMatrixColumn.ifPresent(c -> {
-            if (c < 0 || c >= ShipManager.COLUMNS) {
-                throw new IndexOutOfBoundsException("The specified column is out of the board's bounds.");
-            }
-        });
-
-        return List.of(tileMatrixRow, tileMatrixColumn);
-    }
-
-    /**
-     * Converts the given row and/or column from tile matrix coordinates to board
-     * coordinates.
-     *
-     * <p>
-     * This method adjusts the given row and column indices by adding the board's
-     * starting indices,
-     * as defined in {@link ShipManager#STARTOFBOARDROWS} and
-     * {@link ShipManager#STARTOFBOARDCOLUMNS},
-     * to map them correctly within the board's coordinate system.
-     * </p>
-     *
-     * <p>
-     * If a row or column index is out of bounds, an
-     * {@link IndexOutOfBoundsException} is thrown.
-     * </p>
-     *
-     * @param row    An {@link Optional} containing the row index to convert, or
-     *               empty if not provided.
-     * @param column An {@link Optional} containing the column index to convert, or
-     *               empty if not provided.
-     * @return A list containing two {@link Optional} elements: the converted row
-     *         and column indices.
-     *
-     * @throws IndexOutOfBoundsException If the row or column is out of the board's
-     *                                   valid bounds.
-     */
-    private List<Optional<Integer>> toBoardCoord(Optional<Integer> row, Optional<Integer> column)
-            throws IndexOutOfBoundsException {
-        Optional<Integer> boardRow = row.map(r -> r + ShipManager.STARTOFBOARDROWS);
-        Optional<Integer> boardColumn = column.map(c -> c + ShipManager.STARTOFBOARDCOLUMNS);
-
-        // checking matrix bound
-        boardRow.ifPresent(r -> {
-            if (r < ShipManager.STARTOFBOARDROWS || r >= ShipManager.STARTOFBOARDROWS + ShipManager.ROWS) {
-                throw new IndexOutOfBoundsException("the specified row is out of the board's bound");
-            }
-        });
-        boardColumn.ifPresent(c -> {
-            if (c < ShipManager.STARTOFBOARDCOLUMNS || c >= ShipManager.STARTOFBOARDCOLUMNS + ShipManager.COLUMNS) {
-                throw new IndexOutOfBoundsException("the specified column is out of the board's bound");
-            }
-        });
-
-        return List.of(boardRow, boardColumn);
-    }
-
-    /**
-     * Returns the total number of rows in the ship's grid.
-     *
-     * <p>
-     * This method provides access to the number of rows defined in the
-     * {@link ShipManager}.
-     * </p>
-     *
-     * @return The total number of rows in the ship's grid.
-     */
-    public static int getRows() {
-        return ShipManager.ROWS;
-    }
-
-    /**
-     * Returns the total number of columns in the ship's grid.
-     *
-     * <p>
-     * This method provides access to the number of columns defined in the
-     * {@link ShipManager}.
-     * </p>
-     *
-     * @return The total number of columns in the ship's grid.
-     */
-    public static int getColumns() {
-        return ShipManager.COLUMNS;
-    }
-
-    /**
-     * Retrieves the component located at the specified position in the ship's grid.
-     *
-     * <p>
-     * This method returns an {@link Optional} containing the {@link ComponentTile}
-     * at the given row and column coordinates, if present. If no component exists
-     * at
-     * the specified location, an empty {@code Optional} is returned.
-     * </p>
-     *
-     * <p>
-     * If the specified row or column is out of the valid bounds of the ship,
-     * an {@link IndexOutOfBoundsException} is thrown.
-     * </p>
-     *
-     * @param row    The row index of the component to retrieve.
-     * @param column The column index of the component to retrieve.
-     * @return An {@link Optional} containing the {@link ComponentTile} if present,
-     *         or empty if no component exists.
-     * @throws IndexOutOfBoundsException If the specified row or column is out of
-     *                                   the ship's bounds.
-     */
-    public Optional<ComponentTile> getComponent(int row, int column) throws IndexOutOfBoundsException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        return ship.getComponent(tileCoords.get(0), tileCoords.get(1));
-    }
-
-    public boolean isOutside(int row, int column) throws IndexOutOfBoundsException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        Optional<ComponentTile> component =  ship.getComponent(tileCoords.get(0), tileCoords.get(1));
-
-        return component
-            .map(c -> c.getClass().equals(OutOfBoundsTile.class))
-            .orElse(false);
-    }
-
-    /**
-     * Retrieves all components located in the specified row of the ship's grid.
-     *
-     * <p>
-     * This method returns a list of {@link Optional} elements, each representing a
-     * {@link ComponentTile} located at the given row and every column in the ship's
-     * grid.
-     * If a position does not contain a component, the corresponding
-     * {@code Optional} will be empty.
-     * </p>
-     *
-     * <p>
-     * If the specified row is out of the valid bounds of the ship,
-     * an {@link IndexOutOfBoundsException} is thrown.
-     * </p>
-     *
-     * @param row The row index for which to retrieve all components.
-     * @return A list of {@link Optional<ComponentTile>} representing the components
-     *         in the specified row.
-     * @throws IndexOutOfBoundsException If the specified row is out of the ship's
-     *                                   bounds.
-     */
-    public List<Optional<ComponentTile>> getComponentsAtRow(int row) throws IndexOutOfBoundsException {
-        int tileRow = this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get();
-        List<Optional<ComponentTile>> components = new ArrayList<>();
-
-        for (int i = 0; i < ShipManager.COLUMNS; i++) {
-            components.add(ship.getComponent(tileRow, i));
-        }
-        return components;
-    }
-
-    /**
-     * Retrieves all components located in the specified column of the ship's grid.
-     *
-     * <p>
-     * This method returns a list of {@link Optional} elements, each representing a
-     * {@link ComponentTile} located at the given column and every row in the ship's
-     * grid.
-     * If a position does not contain a component, the corresponding
-     * {@code Optional} will be empty.
-     * </p>
-     *
-     * <p>
-     * If the specified column is out of the valid bounds of the ship,
-     * an {@link IndexOutOfBoundsException} is thrown.
-     * </p>
-     *
-     * @param column The column index for which to retrieve all components.
-     * @return A list of {@link Optional<ComponentTile>} representing the components
-     *         in the specified column.
-     * @throws IndexOutOfBoundsException If the specified column is out of the
-     *                                   ship's bounds.
-     */
-    public List<Optional<ComponentTile>> getComponentsAtColumn(int column) throws IndexOutOfBoundsException {
-        int tileColumn = this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get();
-        List<Optional<ComponentTile>> components = new ArrayList<>();
-
-        for (int i = 0; i < ShipManager.ROWS; i++) {
-            components.add(ship.getComponent(i, tileColumn));
-        }
-        return components;
-    }
-
-    /**
-     * Retrieves the set of all distinct component types present in the ship.
-     *
-     * <p>
-     * This method returns a {@link Set} containing the {@link Class} objects of all
-     * {@link ComponentTile} types currently placed in the ship. Each entry in the
-     * set represents
-     * a unique type of component found on the ship's grid.
-     * </p>
-     *
-     * <p>
-     * If no components are present in the ship, this method returns an empty set.
-     * </p>
-     *
-     * @return A {@link Set} of {@link Class} objects representing the distinct
-     *         component types in the ship,
-     *         or an empty set if no components are present.
-     */
-    public Set<Class<? extends ComponentTile>> getAllComponentsType() {
-        return ship.getAllComponentsTypes();
-    }
-
-    /**
-     * Retrieves the positions of all components of a specified type in board
-     * coordinates.
-     *
-     * <p>
-     * This method returns a {@link Set} of positions where components of the given
-     * type
-     * are located. Each position is represented as a {@link List} of two integers
-     * (row and column).
-     * The positions are converted from tile matrix coordinates to board coordinates
-     * using {@link #toBoardCoord(Optional, Optional)}.
-     * </p>
-     *
-     * <p>
-     * If no components of the specified type are found, an empty set is returned.
-     * </p>
-     *
-     * @param componentType The {@link Class} type of the {@link ComponentTile} to
-     *                      search for.
-     * @return A {@link Set} of {@link List} elements representing the positions of
-     *         the matching components in board coordinates.
-     */
-    public Set<List<Integer>> getAllComponentsPositionOfType(Class<? extends ComponentTile> componentType) {
-        Optional<Set<List<Integer>>> tileComponentPositions = Optional
-                .ofNullable(ship.getAllComponentsPositionOfType(componentType));
-
-        return tileComponentPositions
-                .map(positions -> positions.stream()
-                        .map(coord -> this.toBoardCoord(Optional.of(coord.get(0)), Optional.of(coord.get(1))))
-                        .map(optionalList -> optionalList.stream()
-                                .filter(Optional::isPresent)
-                                .map(Optional::get)
-                                .toList())
-                        .collect(Collectors.toSet()))
-                .orElse(Set.of());
-    }
-
-    /**
-     * Retrieves the disconnected branches of the ship, represented in board
-     * coordinates.
-     *
-     * <p>
-     * A disconnected branch is a set of tiles that are not connected to the main
-     * ship structure.
-     * This method calls {@link ShipBoard#getDisconnectedBranches()} to obtain the
-     * branches in
-     * tile matrix coordinates and then converts them into board coordinates.
-     * </p>
-     *
-     * <p>
-     * The result is a list of sets, where each set represents a disconnected
-     * branch.
-     * Each position in the set is a list of two integers: the row and column of a
-     * component
-     * in board coordinates.
-     * </p>
-     *
-     * <p>
-     * <b>Example of usage:</b>
-     * </p>
-     * 
-     * <pre>
-     * {@code
-     * List<Set<List<Integer>>> branches = shipManager.getDisconnectedBranches();
-     * for (Set<List<Integer>> branch : branches) {
-     *     System.out.println("Disconnected branch: " + branch);
-     * }
-     * </pre>
-     *
-     * @return A list of sets, where each set represents a disconnected branch.
-     */
-    public List<Set<List<Integer>>> getDisconnectedBranches() {
-        List<Set<List<Integer>>> disconnectedBranches = this.ship.getDisconnectedBranches();
-        List<Set<List<Integer>>> DisconnectedBrachesInBoardCoord = new ArrayList<>();
-
-        for (Set<List<Integer>> branch : disconnectedBranches) {
-            Set<List<Integer>> branchInBoardCoord = new HashSet<>();
-
-            for (List<Integer> coord : branch) {
-                List<Optional<Integer>> boardCoord = this.toBoardCoord(Optional.of(coord.get(0)),
-                        Optional.of(coord.get(1)));
-                branchInBoardCoord.add(List.of(boardCoord.get(0).get(), boardCoord.get(1).get()));
-            }
-
-            DisconnectedBrachesInBoardCoord.add(branchInBoardCoord);
-        }
-
-        return DisconnectedBrachesInBoardCoord;
-    }
-
-    /**
-     * Adds a component tile to the specified position in the ship's grid.
-     *
-     * <p>
-     * This method places a given {@link ComponentTile} at the specified row and
-     * column
-     * coordinates. If the position is out of bounds or if the component cannot be
-     * placed
-     * in the given location due to structural constraints, an exception is thrown.
-     * </p>
-     *
-     * @param row       The row index where the component should be placed.
-     * @param column    The column index where the component should be placed.
-     * @param component The {@link ComponentTile} to be added to the ship.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If the component is typing to be
-     *                                           placed outside the ship.
-     */
-    public void addComponentTile(int row, int column, ComponentTile component)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        ship.addComponentTile(tileCoords.get(0), tileCoords.get(1), component);
-    }
-
-    /**
-     * Removes a component tile from the specified position in the ship's grid.
-     *
-     * <p>
-     * This method removes the {@link ComponentTile} located at the given row and
-     * column
-     * coordinates. If the removed component affects other game elements,
-     * appropriate updates
-     * are made.
-     * </p>
-     *
-     * <p>
-     * Special cases:
-     * </p>
-     * <ul>
-     * <li>If the removed component is a {@link CentralCabin} containing a crew, the
-     * crew is removed.</li>
-     * <li>If the removed component is a {@link LifeSupport} module, any nearby
-     * aliens that depend on it are also removed.</li>
-     * </ul>
-     *
-     * @param row    The row index of the component to be removed.
-     * @param column The column index of the component to be removed.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If there is no component at the
-     *                                           specified position.
-     */
-    public void removeComponentTile(int row, int column)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        ComponentTile removedComponent;
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // removing the component
-        removedComponent = ship.removeComponentTile(tileCoords.get(0), tileCoords.get(1));
-        this.discardedTile.add(removedComponent);
-
-        // If was a cabin had an alien, removing aliens from it
-        if (removedComponent instanceof CentralCabin) {
-            CentralCabin removedCabin = (CentralCabin) removedComponent;
-
-            if (removedCabin.getCrewmates().size() == 1) {
-                Crewmate crewmate = removedCabin.getCrewmates().get(0);
-
-                if (crewmate.requiresLifeSupport()) {
-                    Alien alien = (Alien) crewmate;
-                    this.hasAlien.put(alien.getAlienType(), false);
-                }
-            }
-        }
-
-        // If it was a LifeSupport module, removing all nearby aliens
-        if (removedComponent instanceof LifeSupport) {
-            for (Optional<ComponentTile> neighbor : ship.getNeighbourComponents(tileCoords.get(0), tileCoords.get(1))) {
-                if (neighbor.isPresent() && neighbor.get().getClass().equals(CabinModule.class)) {
-                    CabinModule cabin = (CabinModule) neighbor.get();
-
-                    if (cabin.getCrewmates().size() == 1) {
-                        Crewmate crewmate = cabin.getCrewmates().get(0);
-
-                        if (crewmate.requiresLifeSupport()) {
-                            cabin.removeCrewmate();
-
-                            Alien alien = (Alien) crewmate;
-                            this.hasAlien.put(alien.getAlienType(), false);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Removes a specified branch of components from the ship.
-     *
-     * <p>
-     * This method takes a set of coordinates representing a disconnected branch
-     * in board coordinates and removes the corresponding components from the ship.
-     * </p>
-     *
-     * <p>
-     * The given board coordinates are first converted to tile matrix coordinates
-     * before calling {@link ShipBoard#removeBranch(Set)} to remove the branch.
-     * </p>
-     *
-     * <p>
-     * <b>Example of usage:</b>
-     * </p>
-     * 
-     * <pre>
-     * {@code
-     * Set<List<Integer>> branch = Set.of(
-     *         List.of(5, 6),
-     *         List.of(5, 7),
-     *         List.of(6, 7));
-     * shipManager.removeBranch(branch);
-     * }
-     * </pre>
-     *
-     * @param branch A set of positions representing the branch to remove,
-     *               where each position is a list containing two integers (row and
-     *               column) in board coordinates.
-     *
-     * @throws IndexOutOfBoundsException         If any coordinate is out of the
-     *                                           ship's valid bounds.
-     * @throws IllegalComponentPositionException If a specified coordinate does not
-     *                                           correspond to a valid component.
-     */
-    public void removeBranch(Set<List<Integer>> branch)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException {
-        Set<List<Integer>> tileBranch = new HashSet<>();
-
-        for (List<Integer> coord : branch) {
-            List<Optional<Integer>> tileCoord = this.toTileMatrixCoord(Optional.of(coord.get(0)),
-                    Optional.of(coord.get(1)));
-
-            tileBranch.add(List.of(tileCoord.get(0).get(), tileCoord.get(1).get()));
-        }
-
-        this.ship.removeBranch(tileBranch);
-    }
-
-    /**
-     * Determines whether the ship's construction is legal according to the game
-     * rules.
-     *
-     * <p>
-     * The method verifies several conditions to ensure that the ship meets the
-     * requirements:
-     * <ul>
-     * <li>The ship must not be divided into disconnected sections.</li>
-     * <li>All {@link SingleEngine} and {@link DoubleEngine} components must be
-     * oriented backwards (rotation must be 0).</li>
-     * <li>All connectors between adjacent components must be compatible.</li>
-     * </ul>
-     * If any of these conditions are not met, the ship is considered illegal.
-     * </p>
-     *
-     * @return {@code true} if the ship is legal, {@code false} otherwise.
-     */
-    public boolean isShipLegal() {
-        // if the ship is divided into disconnected sections it's not legal
-        if (ship.getDisconnectedBranches().size() > 1) {
-            return false;
-        }
-
-        // checking if single engines are all pointing backwards: if not then it's not
-        // legal
-        Set<List<Integer>> singleEnginePositions = Optional
-                .ofNullable(ship.getAllComponentsPositionOfType(SingleEngine.class))
-                .orElse(Collections.emptySet());
-        for (List<Integer> coord : singleEnginePositions) {
-            if (ship.getComponent(coord.get(0), coord.get(1)).get().getRotation() != 0) {
-                return false;
-            }
-        }
-
-        // checking if double engines are all pointing backwards: if not then it's not
-        // legal
-        Set<List<Integer>> doubleEnginePositions = Optional
-                .ofNullable(ship.getAllComponentsPositionOfType(DoubleEngine.class))
-                .orElse(Collections.emptySet());
-        for (List<Integer> coord : doubleEnginePositions) {
-            if (ship.getComponent(coord.get(0), coord.get(0)).get().getRotation() != 0) {
-                return false;
-            }
-        }
-
-        // checking if connectors match: if not then it's not legal
-        Set<Class<? extends ComponentTile>> componentTypes = ship.getAllComponentsTypes();
-        for (Class<? extends ComponentTile> componentType : componentTypes) {
-            for (List<Integer> coord : ship.getAllComponentsPositionOfType(componentType)) {
-
-                ComponentTile component = ship.getComponent(coord.get(0), coord.get(1)).get();
-                List<Optional<ComponentTile>> neighbors = ship.getNeighbourComponents(coord.get(0), coord.get(1));
-                Optional<ComponentTile> neighbor;
-
-                TileEdge componentConnector;
-                TileEdge neighborConnector;
-
-                // up direction
-                neighbor = neighbors.get(0);
-                if (neighbor.isPresent() && !neighbor.get().getClass().equals(OutOfBoundsTile.class)) {
-                    componentConnector = component.getTileEdges().get(0);
-                    neighborConnector = neighbor.get().getTileEdges().get(2);
-
-                    if (!componentConnector.isCompatible(neighborConnector)) {
-                        return false;
-                    }
-                }
-
-                // right direction
-                neighbor = neighbors.get(1);
-                if (neighbor.isPresent() && !neighbor.get().getClass().equals(OutOfBoundsTile.class)) {
-                    componentConnector = component.getTileEdges().get(1);
-                    neighborConnector = neighbor.get().getTileEdges().get(3);
-
-                    if (!componentConnector.isCompatible(neighborConnector)) {
-                        return false;
-                    }
-                }
-
-                // down direction
-                neighbor = neighbors.get(2);
-                if (neighbor.isPresent() && !neighbor.get().getClass().equals(OutOfBoundsTile.class)) {
-                    componentConnector = component.getTileEdges().get(2);
-                    neighborConnector = neighbor.get().getTileEdges().get(0);
-
-                    if (!componentConnector.isCompatible(neighborConnector)) {
-                        return false;
-                    }
-                }
-
-                // left direction
-                neighbor = neighbors.get(3);
-                if (neighbor.isPresent() && !neighbor.get().getClass().equals(OutOfBoundsTile.class)) {
-                    componentConnector = component.getTileEdges().get(3);
-                    neighborConnector = neighbor.get().getTileEdges().get(1);
-
-                    if (!componentConnector.isCompatible(neighborConnector)) {
-                        return false;
-                    }
-                }
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Adds a human crewmate to a specified position within the ship.
-     *
-     * <p>
-     * This method attempts to place a given {@link Human} crewmate at the specified
-     * row and column coordinates on the ship. The following conditions are checked:
-     * </p>
-     * <ul>
-     * <li>The target position must contain a valid {@link CentralCabin} instance;
-     * otherwise,
-     * an {@link IllegalComponentPositionException} is thrown.</li>
-     * <li>If no component exists at the specified position, an
-     * {@link IllegalComponentPositionException} is thrown.</li>
-     * </ul>
-     *
-     * <p>
-     * If all conditions are met, the human crewmate is added to the cabin.
-     * </p>
-     *
-     * @param row      The row index where the crewmate should be placed.
-     * @param column   The column index where the crewmate should be placed.
-     * @param crewmate The {@link Human} crewmate to be added to the cabin.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If the target position does not
-     *                                           contain a valid cabin module.
-     * @throws InvalidActionException            If the cabin is full.
-     */
-    public void addCrewmate(int row, int column, Human crewmate)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException, InvalidActionException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // check if is empty or it's not a cabin module
-        ComponentTile component = ship.getComponent(tileCoords.get(0), tileCoords.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException("There is no element here"));
-        if (!(component instanceof CentralCabin)) {
-            throw new IllegalComponentPositionException("Not a cabin module at [" + row + "][" + column + "]");
-        }
-
-        CentralCabin cabin = (CentralCabin) component;
-        cabin.addCrewmate(crewmate);
-    }
-
-    /**
-     * Adds an alien crewmate to a specified position within the ship.
-     *
-     * <p>
-     * This method attempts to place a given {@link Alien} crewmate at the specified
-     * row and column coordinates on the ship. Before adding the alien, the
-     * following
-     * conditions are checked:
-     * </p>
-     * <ul>
-     * <li>An alien of the same type has not already been placed. If an alien of
-     * this
-     * type is already present, an {@link InvalidActionException} is thrown.</li>
-     * <li>The target position must contain a valid {@link CabinModule}; otherwise,
-     * an {@link IllegalComponentPositionException} is thrown.</li>
-     * <li>A compatible {@link LifeSupport} module must be adjacent to the cabin. If
-     * not,
-     * an {@link InvalidActionException} is thrown.</li>
-     * </ul>
-     *
-     * <p>
-     * If all conditions are met, the alien is added to the cabin, and its type is
-     * recorded
-     * to prevent placing another alien of the same type.
-     * </p>
-     *
-     * @param row      The row index where the crewmate should be placed.
-     * @param column   The column index where the crewmate should be placed.
-     * @param crewmate The {@link Alien} crewmate to be added to the cabin.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If the target position does not
-     *                                           contain a valid cabin module.
-     * @throws InvalidActionException            If an alien of this type is already
-     *                                           present or if no
-     *                                           compatible life support module is
-     *                                           adjacent or if the cabin is full.
-     */
-    public void addCrewmate(int row, int column, Alien crewmate)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException, InvalidActionException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // check if the alien color is already present
-        if (this.hasAlien(crewmate.getAlienType())) {
-            throw new InvalidActionException("You already placed an alien of this color");
-        }
-
-        // check if is empty or it's not a cabin module
-        ComponentTile component = ship.getComponent(tileCoords.get(0), tileCoords.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException("There is no element here"));
-        if (!(component instanceof CentralCabin)) {
-            throw new IllegalComponentPositionException("Not a cabin module at [" + row + "][" + column + "]");
-        }
-
-        CabinModule cabin = (CabinModule) component;
-
-        // check for life support module near the cabin
-        List<Optional<ComponentTile>> neighbors = this.ship.getNeighbourComponents(tileCoords.get(0),
-                tileCoords.get(1));
-
-        boolean hasLifeSupport = neighbors.stream()
-                .flatMap(Optional::stream)
-                .filter(neighbor -> neighbor instanceof LifeSupport)
-                .map(neighbor -> (LifeSupport) neighbor)
-                .anyMatch(l -> l.getSupportedAlienType().equals(crewmate.getAlienType()));
-
-        if (!hasLifeSupport) {
-            throw new InvalidActionException("The cabin module has not a life support module nearby");
-        }
-
-        cabin.addCrewmate(crewmate);
-        this.hasAlien.put(crewmate.getAlienType(), true);
-    }
-
-    /**
-     * Removes a crewmate from the specified position within the ship.
-     *
-     * <p>
-     * This method attempts to remove a crewmate from the cabin located at the
-     * specified
-     * row and column coordinates. The following conditions are checked:
-     * </p>
-     * <ul>
-     * <li>The target position must contain a valid {@link CentralCabin} instance;
-     * otherwise,
-     * an {@link IllegalComponentPositionException} is thrown.</li>
-     * <li>If no component exists at the specified position, an
-     * {@link IllegalComponentPositionException} is thrown.</li>
-     * </ul>
-     *
-     * <p>
-     * If the removed crewmate is an alien requiring life support, the alien type is
-     * marked as no longer present in the ship.
-     * </p>
-     *
-     * @param row    The row index of the cabin from which the crewmate should be
-     *               removed.
-     * @param column The column index of the cabin from which the crewmate should be
-     *               removed.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If there is no component at the
-     *                                           specified position
-     *                                           or if the component is not an
-     *                                           instance of {@link CentralCabin}.
-     * @throws InvalidActionException            If the cabin has no crew.
-     */
-    public void removeCrewmate(int row, int column)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException, InvalidActionException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // check if is empty or it's not a cabin module
-        ComponentTile component = ship.getComponent(tileCoords.get(0), tileCoords.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException("There is no element here"));
-        if (!(component instanceof CentralCabin)) {
-            throw new IllegalComponentPositionException("Not a cabin module at [" + row + "][" + column + "]");
-        }
-
-        CentralCabin cabin = (CentralCabin) component;
-        Crewmate crewmate = cabin.removeCrewmate();
-        if (crewmate.requiresLifeSupport()) {
-            Alien alien = (Alien) crewmate;
-            this.hasAlien.put(alien.getAlienType(), false);
-        }
-    }
-
-    /**
-     * Adds a cargo item to a cargo holder at the specified position within the
-     * ship.
-     *
-     * <p>
-     * This method attempts to place a given {@link Cargo} at the specified row and
-     * column
-     * coordinates on the ship. If the cargo is special, it must be placed in a
-     * {@link SpecialCargoHold}.
-     * If the target position does not contain the correct type of cargo holder, an
-     * exception is thrown.
-     * </p>
-     *
-     * @param row    The row index where the cargo should be placed.
-     * @param column The column index where the cargo should be placed.
-     * @param cargo  The {@link Cargo} to be added to the cargo hold.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If the target position does not
-     *                                           contain a cargo holder or
-     *                                           if the cargo type is not compatible
-     *                                           with the cargo holder type.
-     * @throws InvalidActionException            If the cargo holder is full.
-     */
-    public void addCargo(int row, int column, Cargo cargo)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException, InvalidActionException {
-        CargoHold cargoHoldComponent;
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // check if is empty
-        ComponentTile component = ship.getComponent(tileCoords.get(0), tileCoords.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException("There is no element here"));
-        // check the cargo hold type depending on cargo specialty
-        if (cargo.isSpecial()) {
-            if (!component.getClass().equals(SpecialCargoHold.class)) {
-                throw new IllegalComponentPositionException(
-                        "Not a special cargo hold module at [" + row + "][" + column + "]");
-            }
-            cargoHoldComponent = (SpecialCargoHold) component;
-        } else {
-            if (!(component instanceof CargoHold)) {
-                throw new IllegalComponentPositionException("Not a cargo hold module at [" + row + "][" + column + "]");
-            }
-            cargoHoldComponent = (CargoHold) component;
-        }
-
-        cargoHoldComponent.addCargo(cargo);
-    }
-
-    /**
-     * Removes a cargo item of the specified color from a cargo hold at the given
-     * position.
-     *
-     * <p>
-     * This method attempts to remove a {@link Cargo} item that matches the given
-     * {@link Color}
-     * from the cargo hold located at the specified row and column coordinates on
-     * the ship.
-     * If the cargo color is red, the method expects a {@link SpecialCargoHold}.
-     * If the correct type of cargo hold is not present, or if no cargo of the
-     * specified color is found, an exception is thrown.
-     * </p>
-     *
-     * @param row    The row index of the cargo hold.
-     * @param column The column index of the cargo hold.
-     * @param color  The {@link Color} of the cargo to be removed.
-     *
-     * @throws IndexOutOfBoundsException         If the specified row or column is
-     *                                           out of the ship's bounds.
-     * @throws IllegalComponentPositionException If the target position does not
-     *                                           contain a cargo hold or
-     *                                           if the cargo type is not compatible
-     *                                           with the cargo hold type.
-     * @throws InvalidActionException            If no cargo of the specified color
-     *                                           is found or if the cargo holder is
-     *                                           empty.
-     */
-    public void removeCargo(int row, int column, Color color)
-            throws IndexOutOfBoundsException, IllegalComponentPositionException, InvalidActionException {
-        CargoHold cargoHoldComponent;
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // check if is empty
-        ComponentTile component = ship.getComponent(tileCoords.get(0), tileCoords.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException("There is no element here"));
-        // check the cargo hold type depending on cargo specialty
-        if (color.equals(Color.RED)) {
-            if (!component.getClass().equals(SpecialCargoHold.class)) {
-                throw new IllegalComponentPositionException(
-                        "Not a special cargo hold module at [" + row + "][" + column + "]");
-            }
-            cargoHoldComponent = (SpecialCargoHold) component;
-        } else {
-            if (!(component instanceof CargoHold)) {
-                throw new IllegalComponentPositionException("Not a cargo hold module at [" + row + "][" + column + "]");
-            }
-            cargoHoldComponent = (CargoHold) component;
-        }
-
-        List<Cargo> cargo = cargoHoldComponent.getContainedCargo();
-        OptionalInt position = IntStream.range(0, cargo.size())
-                .filter(i -> cargo.get(i).getColor().equals(color))
-                .findFirst();
-
-        if (position.isPresent()) {
-            cargo.remove(position.getAsInt());
-        } else {
-            throw new InvalidActionException("There are not " + color + " cargo at [" + row + "][" + column + "]");
-        }
-    }
-
-    /**
-     * Removes a battery component from the specified position within the ship.
-     *
-     * <p>
-     * This method attempts to remove a battery from the module located at the
-     * specified
-     * row and column coordinates on the ship. If the component does not exist or is
-     * not a {@link BatteryComponent},
-     * an exception is thrown.
-     * </p>
-     *
-     * <p>
-     * The method does not physically remove the battery component but instead
-     * triggers energy consumption within it.
-     * </p>
-     *
-     * @param row    The row index of the battery module.
-     * @param column The column index of the battery module.
-     *
-     * @throws IllegalComponentPositionException If there is no component at the
-     *                                           specified position or
-     *                                           if the component is not a
-     *                                           {@link BatteryComponent}.
-     * @throws InvalidActionException            If the component has no battery
-     *                                           left.
-     */
-    public void removeBattery(int row, int column) throws IllegalComponentPositionException, InvalidActionException {
-        BatteryComponent batteryComponent;
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        // check if is empty or it's not a battery component
-        ComponentTile component = ship.getComponent(tileCoords.get(0), tileCoords.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException("There is no element here"));
-        if (!component.getClass().equals(BatteryComponent.class)) {
-            throw new IllegalComponentPositionException("Not a battery hold module at [" + row + "][" + column + "]");
-        }
-
-        batteryComponent = (BatteryComponent) component;
-        batteryComponent.consumeEnergy();
-    }
-
-    /**
-     * Retrieves the positions of all cargo items aboard the ship, grouped by color.
-     *
-     * <p>This method scans all cargo hold components ({@link CargoHold} and {@link SpecialCargoHold})
-     * and collects the positions of cargo items based on their color.</p>
-     *
-     * <p>The result is a {@link HashMap} where each key is a {@link Color} representing a cargo type,
-     * and the corresponding value is a set of positions (row and column) where cargo of that color is stored.</p>
-     *
-     * <h3>Functionality:</h3>
-     * <ul>
-     *     <li>Iterates over all colors defined in {@link Color}.</li>
-     *     <li>Scans all {@link SpecialCargoHold} components for special cargo.</li>
-     *     <li>Scans all {@link CargoHold} components for non-special cargo.</li>
-     *     <li>Groups the cargo positions by color.</li>
-     * </ul>
-     *
-     * <p>Example of usage:</p>
-     * <pre>
-     *     HashMap<Color, Set<List<Integer>>> cargoPositions = shipManager.getCargoPosition();
-     *     for (Map.Entry<Color, Set<List<Integer>>> entry : cargoPositions.entrySet()) {
-     *         System.out.println("Color: " + entry.getKey() + ", Positions: " + entry.getValue());
-     *     }
-     * </pre>
-     *
-     * @return A {@link HashMap} where the key is a {@link Color}, and the value is a {@link Set} 
-     *         of positions (row, column) where cargo of that color is stored.
-     */
-    public HashMap<Color, Set<List<Integer>>> getCargoPositon() {
-        HashMap<Color, Set<List<Integer>>> cargoPosition = new HashMap<>();
-
-        for (Color color : Color.values()) {
-            Set<List<Integer>> positions = new HashSet<>();
-            cargoPosition.put(color, positions);
-
-            Set<List<Integer>> specialCargoHoldComponent = this.getAllComponentsPositionOfType(SpecialCargoHold.class);
-
-            for (List<Integer> coord : specialCargoHoldComponent) {
-                SpecialCargoHold specialCargoHold = (SpecialCargoHold) this.getComponent(coord.get(0), coord.get(1)).get();
-
-                List<Cargo> containedCargo = specialCargoHold.getContainedCargo();
-
-                for (Cargo cargo : containedCargo) {
-                    if (cargo.getColor().equals(color)) {
-                        positions.add(coord);
-                    }
-                }
-            }
-
-            Cargo specialCargo = new Cargo(color);
-
-            if (specialCargo.isSpecial()) {
-                continue;
-            }
-
-            Set<List<Integer>> cargoHoldComponent = this.getAllComponentsPositionOfType(CargoHold.class);
-
-            for (List<Integer> coord : cargoHoldComponent) {
-                CargoHold cargoHold = (CargoHold) this.getComponent(coord.get(0), coord.get(1)).get();
-
-                List<Cargo> containedCargo = cargoHold.getContainedCargo();
-
-                for (Cargo cargo : containedCargo) {
-                    if (cargo.getColor().equals(color)) {
-                        positions.add(coord);
-                    }
-                }
-            }
-        }
-
-        return cargoPosition;
-    }
-
-    /**
-     * Counts the number of exposed connectors of the component at the specified
-     * position.
-     *
-     * <p>
-     * This method determines how many connectors of the {@link ComponentTile} at
-     * the given
-     * row and column are exposed, meaning they are not connected to a compatible
-     * neighbor.
-     * </p>
-     *
-     * <p>
-     * If the specified row or column is out of bounds, an
-     * {@link IndexOutOfBoundsException} is thrown.
-     * </p>
-     *
-     * @param row    The row index of the component.
-     * @param column The column index of the component.
-     * @return The number of exposed connectors of the component at the specified
-     *         position. If the position is empty or outside the board, returns 0
-     * @throws IndexOutOfBoundsException If the specified row or column is out of
-     *                                   the ship's bounds.
-     */
-    public int countExposedConnectorsOf(int row, int column) throws IndexOutOfBoundsException {
-        List<Integer> tileCoords = new ArrayList<>();
-        tileCoords.add(this.toTileMatrixCoord(Optional.of(row), Optional.empty()).get(0).get());
-        tileCoords.add(this.toTileMatrixCoord(Optional.empty(), Optional.of(column)).get(1).get());
-
-        return ship.countExposedConnectors(tileCoords.get(0), tileCoords.get(1));
-    }
-
-    /**
-     * Counts the total number of exposed connectors across all components in the
-     * ship.
-     *
-     * <p>
-     * This method iterates over all component types present in the ship and
-     * accumulates the number of exposed connectors for each component. A connector
-     * is
-     * considered exposed if it is not connected to a compatible neighboring
-     * component.
-     * </p>
-     *
-     * <p>
-     * Components of type {@link OutOfBoundsTile} are ignored in this calculation.
-     * </p>
-     *
-     * @return The total number of exposed connectors in the ship.
-     * @throws IndexOutOfBoundsException If an invalid coordinate is encountered
-     *                                   during the computation.
-     */
-    public int countAllExposedConnectors() throws IndexOutOfBoundsException {
-        int exposedConnectors = 0;
-        Set<Class<? extends ComponentTile>> componentTypes = ship.getAllComponentsTypes();
-
-        for (Class<? extends ComponentTile> componentType : componentTypes) {
-            if (componentType != OutOfBoundsTile.class) {
-                for (List<Integer> coord : ship.getAllComponentsPositionOfType(componentType)) {
-                    exposedConnectors += ship.countExposedConnectors(coord.get(0), coord.get(1));
-                }
-            }
-        }
-        return exposedConnectors;
-    }
-
-    /**
-     * Counts the total number of human crewmates aboard the ship.
-     *
-     * <p>
-     * This method iterates through all {@link CentralCabin} and {@link CabinModule}
-     * components
-     * to count the number of human crewmates present. A crewmate is considered
-     * human if
-     * they do not require life support.
-     * </p>
-     *
-     * <p>
-     * The method first collects all crewmates in {@link CentralCabin} components,
-     * as they are
-     * exclusively human. Then, it checks each crewmate in {@link CabinModule}
-     * components and
-     * includes only those that do not require life support.
-     * </p>
-     *
-     * @return The total number of human crewmates aboard the ship.
-     */
-    public int countHumans() {
-        Set<List<Integer>> centralCabinsCoords = this.getAllComponentsPositionOfType(CentralCabin.class);
-        Set<List<Integer>> cabinCoords = this.getAllComponentsPositionOfType(CabinModule.class);
-        int humans = 0;
-
-        for (List<Integer> coord : centralCabinsCoords) {
-            CentralCabin cabin = (CentralCabin) this.getComponent(coord.get(0), coord.get(1)).get();
-
-            humans += cabin.getCrewmates().size();
-        }
-
-        for (List<Integer> coord : cabinCoords) {
-            CabinModule cabin = (CabinModule) this.getComponent(coord.get(0), coord.get(1)).get();
-
-            List<Crewmate> crewmates = cabin.getCrewmates();
-            for (Crewmate crewmate : crewmates) {
-                if (!crewmate.requiresLifeSupport()) {
-                    humans++;
-                }
-            }
-        }
-        return humans;
-    }
-
-    public boolean hasAlien(AlienType type) {
-        if (Optional.ofNullable(this.hasAlien.get(type)).isPresent() && this.hasAlien.get(type)) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Counts the total number of crewmates aboard the ship.
-     *
-     * <p>
-     * This method iterates through all {@link CentralCabin} and {@link CabinModule}
-     * components
-     * to count the number of crewmates present. Crewmates can be either human or
-     * alien.
-     * </p>
-     *
-     * <p>
-     * The method first collects all crewmates from {@link CentralCabin} components,
-     * then
-     * continues by counting those in {@link CabinModule} components.
-     * </p>
-     *
-     * @return The total number of crewmates aboard the ship.
-     */
-    public int countCrewmates() {
-        Set<List<Integer>> centralCabinsCoords = this.getAllComponentsPositionOfType(CentralCabin.class);
-        Set<List<Integer>> cabinCoords = this.getAllComponentsPositionOfType(CabinModule.class);
-        int crewmates = 0;
-
-        for (List<Integer> coord : centralCabinsCoords) {
-            CentralCabin cabin = (CentralCabin) this.getComponent(coord.get(0), coord.get(1)).get();
-
-            crewmates += cabin.getCrewmates().size();
-        }
-
-        for (List<Integer> coord : cabinCoords) {
-            CabinModule cabin = (CabinModule) this.getComponent(coord.get(0), coord.get(1)).get();
-
-            crewmates += cabin.getCrewmates().size();
-        }
-        return crewmates;
-    }
-
-    /**
-     * Calculates the total firepower of the ship.
-     *
-     * <p>This method computes the total firepower by summing the base firepower of all 
-     * {@link SingleCannon} components present on the ship.</p>
-     *
-     * <h3>Firepower Calculation:</h3>
-     * <ul>
-     *     <li>Retrieves all {@link SingleCannon} components aboard the ship.</li>
-     *     <li>Sum their individual firepower values.</li>
-     *     <li>If a {@link AlienType#PURPLEALIEN} is present, an additional bonus of +2 firepower is applied.</li>
-     * </ul>
-     *
-     * <p>Example of usage:</p>
-     * <pre>
-     *     double totalFirePower = shipManager.calculateFirePower();
-     *     System.out.println("Total firepower: " + totalFirePower);
-     * </pre>
-     *
-     * @return The total firepower of the ship. Returns {@code 0.0} if no cannons are present.
-     */
-    public double calculateFirePower() {
-        Set<List<Integer>> singleCannonCoords = this.getAllComponentsPositionOfType(SingleCannon.class);
-        double firePower = 0.0;
-
-        for (List<Integer> coord : singleCannonCoords) {
-            SingleCannon cannon = (SingleCannon) this.getComponent(coord.get(0), coord.get(1)).get();
-            firePower += cannon.getFirePower();
-        }
-
-        if (firePower > 0.0 && this.hasAlien(AlienType.PURPLEALIEN)) {
-            firePower += 2;
-        }
-
-        return firePower;
-    }
-
-    /**
-     * Calculates the total engine power of the ship.
-     *
-     * <p>This method computes the total engine power by summing the power values of all
-     * {@link SingleEngine} components present on the ship.</p>
-     *
-     * <h3>Engine Power Calculation:</h3>
-     * <ul>
-     *     <li>Retrieves all {@link SingleEngine} components aboard the ship.</li>
-     *     <li>Summates their individual engine power values.</li>
-     *     <li>If a {@link AlienType#BROWNALIEN} is present, an additional bonus of +2 engine power is applied.</li>
-     * </ul>
-     *
-     * <p>Example of usage:</p>
-     * <pre>
-     *     int totalEnginePower = shipManager.calculateEnginePower();
-     *     System.out.println("Total engine power: " + totalEnginePower);
-     * </pre>
-     *
-     * @return The total engine power of the ship. Returns {@code 0} if no engines are present.
-     */
-    public int calculateEnginePower() {
-        Set<List<Integer>> singleEngineCoords = this.getAllComponentsPositionOfType(SingleEngine.class);
-        int enginePower = 0;
-
-        for (List<Integer> coord : singleEngineCoords) {
-            SingleEngine engine = (SingleEngine) this.getComponent(coord.get(0), coord.get(1)).get();
-
-            enginePower += engine.getEnginePower();
-        }
-
-        if (enginePower > 0.0 && this.hasAlien(AlienType.BROWNALIEN)) {
-            enginePower += 2;
-        }
-
-        return enginePower;
-    }
-
-    /**
-     * Activates a set of components using specified battery components.
-     *
-     * <p>This method allows activating multiple {@link EnergyConsumer} components by consuming energy from 
-     * associated {@link BatteryComponent} modules. Each activation is represented by a mapping between 
-     * a component's position and the corresponding battery's position.</p>
-     *
-     * <h3>Activation Process:</h3>
-     * <ul>
-     *     <li>Iterates over the provided mapping of component coordinates to battery coordinates.</li>
-     *     <li>Verifies that both the target component and the battery exist at their respective positions.</li>
-     *     <li>Ensures that the target component implements {@link EnergyConsumer}.</li>
-     *     <li>Activates the component and accumulates the resulting power.</li>
-     *     <li>Consumes energy from the specified {@link BatteryComponent}.</li>
-     * </ul>
-     *
-     * <p>Example of usage:</p>
-     * <pre>
-     *     HashMap<List<Integer>, List<Integer>> activations = new HashMap<>();
-     *     activations.put(List.of(2, 3), List.of(1, 4)); // Activate component at (2,3) using battery at (1,4)
-     *
-     *     double totalPower = shipManager.activateComponent(activations);
-     *     System.out.println("Total activated power: " + totalPower);
-     * </pre>
-     *
-     * @param componentAndBatteries A mapping between the coordinates of components to be activated 
-     *                              and the coordinates of their corresponding battery components.
-     * @return The total power generated by all activated components.
-     * @throws IllegalComponentPositionException If any of the specified positions do not contain valid components.
-     * @throws InvalidActionException If any component is not an {@link EnergyConsumer}, 
-     *                                if the battery component is invalid, or if activation fails.
-     * @throws IllegalComponentPositionException If any of the specified positions does not contain a valid component.
-     */
-    public double activateComponent(HashMap<List<Integer>, List<Integer>> componentAndBatteries) throws IndexOutOfBoundsException, InvalidActionException, IllegalComponentPositionException {
-        double power = 0;
-
-        for (List<Integer> componentCoord : componentAndBatteries.keySet()) {
-            List<Integer> batteryCoord = componentAndBatteries.get(componentCoord);
-
-            //if one of the specified coordinates is empty
-            ComponentTile component = this.getComponent(componentCoord.get(0), componentCoord.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException(
-                    "The component at [" + componentCoord.get(0) + "][" + componentCoord.get(1) + "] is empty"
-                ));
-            ComponentTile batteryComponent = this.getComponent(batteryCoord.get(0), batteryCoord.get(1))
-                .orElseThrow(() -> new IllegalComponentPositionException(
-                    "The component at [" + batteryCoord.get(0) + "][" + batteryCoord.get(1) + "] is empty"
-                ));
-
-            //if the specified component is not activable
-            if (component instanceof EnergyConsumer) {
-                EnergyConsumer consumer = (EnergyConsumer) component;
-                power += consumer.activate();
-            } else {
-                throw new InvalidActionException("The component can't use a battery");
-            }
-            //if the specified component is a battery component
-            if (batteryComponent instanceof BatteryComponent) {
-                this.removeBattery(batteryCoord.get(0), batteryCoord.get(1));
-            } else {
-                throw new InvalidActionException("The component is not a battery");
-            }
-        }
-
-        return power;
-    }
-
-    /**
-     * Calculates the total firepower of the ship, including activated double cannons.
-     *
-     * <p>This method computes the base firepower from all {@link SingleCannon} components 
-     * and adds the additional firepower generated by activating {@link DoubleCannon} components 
-     * using batteries.</p>
-     *
-     * <h3>Firepower Calculation:</h3>
-     * <ul>
-     *     <li>Retrieves the base firepower from existing {@link SingleCannon} components.</li>
-     *     <li>Checks if any firepower is present before activation.</li>
-     *     <li>Activates {@link DoubleCannon} components using the provided battery mappings.</li>
-     *     <li>If no cannons were active before activation, but at least one was activated, 
-     *         and the ship has a {@link AlienType#PURPLEALIEN}, an additional +2 firepower bonus is applied.</li>
-     * </ul>
-     *
-     * <h3>Example of usage:</h3>
-     * <pre>
-     *     HashMap<List<Integer>, List<Integer>> activations = new HashMap<>();
-     *     activations.put(List.of(2, 3), List.of(1, 4)); // Activate double cannon at (2,3) using battery at (1,4)
-     *
-     *     double totalFirepower = shipManager.calculateFirePower(activations);
-     *     System.out.println("Total firepower: " + totalFirepower);
-     * </pre>
-     *
-     * @param doubleCannonsAndBatteries A mapping between the coordinates of {@link DoubleCannon} components 
-     *                                  and the coordinates of their corresponding battery components.
-     * @return The total firepower of the ship, including activated cannons and any alien bonuses.
-     * @throws IndexOutOfBoundsException If any of the specified coordinates are out of bounds.
-     * @throws InvalidActionException If any of the components cannot be activated 
-     *                                or if an invalid battery is provided.
-     * @throws IllegalComponentPositionException If any of the specified positions do not contain valid components.
-    */
-    public double calculateFirePower(HashMap<List<Integer>, List<Integer>> doubleCannonsAndBatteries) throws IndexOutOfBoundsException, InvalidActionException, IllegalComponentPositionException {
-        boolean activedAliens = false;
-        double firePower = this.calculateFirePower();
-
-        if (firePower > 0.0) {
-            activedAliens = true;
-        }
-
-        firePower += this.activateComponent(doubleCannonsAndBatteries);
-
-        if (!activedAliens && firePower > 0 && this.hasAlien(AlienType.PURPLEALIEN)) {
-            firePower += 2;
-        }
-
-        return firePower;
-    }
-
-    /**
-     * Calculates the total engine power of the ship, including activated double engines.
-     *
-     * <p>This method computes the base engine power from all {@link SingleEngine} components 
-     * and adds the additional power generated by activating {@link DoubleEngine} components 
-     * using batteries.</p>
-     *
-     * <h3>Engine Power Calculation:</h3>
-     * <ul>
-     *     <li>Retrieves the base engine power from existing {@link SingleEngine} components.</li>
-     *     <li>Checks if any engine power is present before activation.</li>
-     *     <li>Activates {@link DoubleEngine} components using the provided battery mappings.</li>
-     *     <li>If no engines were active before activation, but at least one was activated, 
-     *         and the ship has a {@link AlienType#BROWNALIEN}, an additional +2 engine power bonus is applied.</li>
-     * </ul>
-     *
-     * <h3>Example of usage:</h3>
-     * <pre>
-     *     HashMap<List<Integer>, List<Integer>> activations = new HashMap<>();
-     *     activations.put(List.of(3, 2), List.of(2, 3)); // Activate double engine at (3,2) using battery at (2,3)
-     *
-     *     int totalEnginePower = shipManager.calculateEnginePower(activations);
-     *     System.out.println("Total engine power: " + totalEnginePower);
-     * </pre>
-     *
-     * @param doubleEnginesAndBatteries A mapping between the coordinates of {@link DoubleEngine} components 
-     *                                  and the coordinates of their corresponding battery components.
-     * @return The total engine power of the ship, including activated engines and any alien bonuses.
-     * @throws IndexOutOfBoundsException If any of the specified coordinates are out of bounds.
-     * @throws InvalidActionException If any of the components cannot be activated 
-     *                                or if an invalid battery is provided.
-     * @throws IllegalComponentPositionException If any of the specified positions do not contain valid components.
-     */
-    public int calculateEnginePower(HashMap<List<Integer>, List<Integer>> doubleEnginesAndBatteries) throws IndexOutOfBoundsException, InvalidActionException, IllegalComponentPositionException {
-        boolean activedAliens = false;
-        int enginePower = this.calculateEnginePower();
-
-        if (enginePower > 0.0) {
-            activedAliens = true;
-        }
-
-        enginePower += this.activateComponent(doubleEnginesAndBatteries);
-
-        if (!activedAliens && enginePower > 0 && this.hasAlien(AlienType.BROWNALIEN)) {
-            enginePower += 2;
-        }
-
-        return enginePower;
-    }
-}
Index: src/main/java/it/polimi/it/galaxytrucker/managers/CargoManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/CargoManager.java b/src/main/java/it/polimi/it/galaxytrucker/managers/CargoManager.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/CargoManager.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,56 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import it.polimi.it.galaxytrucker.componenttiles.BatteryComponent;
-import it.polimi.it.galaxytrucker.utility.Cargo;
-import it.polimi.it.galaxytrucker.utility.Color;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class CargoManager {
-
-
-    public void manageCargoDischarge(int reqCargo, Player player) {
-        ShipManager shipManager = player.getShipManager();
-        Color[] colors = Color.values();
-        int consumedCargo = 0;
-
-        // Checks for cargo of each color (from most to least precious)
-        for (int i = colors.length - 1; i >= 0; i--) {
-            if (!shipManager.getCargoPositon().get(colors[i]).isEmpty()) {
-                // Removes most valuable cargo first, the passes to second most valuable, etc.
-                for (List<Integer> pos : shipManager.getCargoPositon().get(colors[i])) {
-                    shipManager.removeCargo(pos.get(0), pos.get(1), colors[i]);
-                    consumedCargo++;
-                    // If the required amount of cargo has been removed, exits the loop
-                    if (consumedCargo == reqCargo) return;
-                }
-            }
-        }
-
-        // If there wasn't enough cargo to remove, batteries are removed to make up the difference
-        if (consumedCargo < reqCargo) {
-            for (List<Integer> pos : shipManager.getAllComponentsPositionOfType(BatteryComponent.class)) {
-                // Make sure there is energy in the BatteryComponent
-                while (((BatteryComponent) shipManager.getComponent(pos.get(0), pos.get(1)).get()).getBatteryCapacity() != 0) {
-                    shipManager.removeBattery(pos.get(0), pos.get(1));
-                    consumedCargo++;
-                    // If the required amount of cargo has been removed, exits the loop
-                    if (consumedCargo == reqCargo) return;
-                }
-            }
-        }
-
-        // If there aren't enough batteries to make up the difference, there is nothing more to do and the function returns
-    }
-
-
-
-    public void manageCargoAddition(Cargo load, Player player) {
-            List<Integer> position = new ArrayList<Integer>();
-            position.add(7);
-            position.add(6);
-         //   position = waitingCoordinates();
-            player.getShipManager().addCargo(position.get(0),position.get(1),load);
-    }
-}
Index: src/main/java/it/polimi/it/galaxytrucker/managers/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/Player.java b/src/main/java/it/polimi/it/galaxytrucker/managers/Player.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/Player.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,60 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import java.util.UUID;
-
-import it.polimi.it.galaxytrucker.utility.Color;
-
-public class Player {
-    private UUID PlayerID;
-    private String PlayerName;
-    private int credits;
-    private Color color;
-    private ShipManager shipManager;
-
-    public Player(UUID playerID, String playerName, int credits, Color color,ShipManager shipManager) {
-        this.PlayerID = playerID;
-        this.PlayerName = playerName;
-        this.credits = credits;
-        this.color = color;
-        this.shipManager = shipManager;
-    }
-
-    public Player(UUID playerID, String playerName, int credits, Color color) {
-        this.PlayerID = playerID;
-        this.PlayerName = playerName;
-        this.credits = credits;
-        this.color = color;
-    }
-
-    public Player(UUID playerID) {
-        this.PlayerID = playerID;
-    }
-
-    public UUID getPlayerID() {
-        return PlayerID;
-    }
-
-    public String getPlayerName() {
-        return PlayerName;
-    }
-
-    public int getCredits() {
-        return credits;
-    }
-
-    public Color getColor() {
-        return color;
-    }
-
-    public ShipManager getShipManager() {
-        return shipManager;
-    }
-
-    public void addCredits(int credits) {
-        this.credits = this.credits + credits;
-    }
-
-    public void createShip(int level) {
-        this.shipManager = new ShipManager(level);
-    }
-}
Index: src/main/java/it/polimi/it/galaxytrucker/managers/FlightBoardState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/polimi/it/galaxytrucker/managers/FlightBoardState.java b/src/main/java/it/polimi/it/galaxytrucker/managers/FlightBoardState.java
deleted file mode 100644
--- a/src/main/java/it/polimi/it/galaxytrucker/managers/FlightBoardState.java	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ /dev/null	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
@@ -1,177 +0,0 @@
-package it.polimi.it.galaxytrucker.managers;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import java.util.List;
-import java.util.UUID;
-
-// quando si genera nuovo ID, deve essere diverso da UUID(0,0)
-
-public class FlightBoardState {
-
-    private Player[] board;
-    private HashMap<Player,Integer> playerPosition;
-    private HashMap<Player,Integer> compleatedTurns;
-
-
-    public FlightBoardState(int dimension) {
-        board = new Player[dimension];
-        setBoard();
-        playerPosition = new HashMap<Player,Integer>();
-        compleatedTurns = new HashMap<Player,Integer>();
-    }
-
-    public void setBoard() {
-        for(int i = 0; i < board.length; i++){
-            board[i] = new Player(new UUID(0,0));
-        }
-    }
-
-    public Player[] getBoard() {
-        return board;
-    }
-
-    public HashMap<Player, Integer> getPlayerPosition() {
-        return playerPosition;
-    }
-
-    public HashMap<Player, Integer> getCompleatedTurns() {
-        return compleatedTurns;
-    }
-
-    public void printFlightBoardState() {
-        System.out.println( "Flight Board State");
-        System.out.println();
-        System.out.println();
-        int dimension = board.length;
-
-        // 0    1    2   3   4   5   6   7
-
-        // ID   Id       ID      ID
-
-        // 8    9   10  11  12  13  14  15
-
-        // ID(?) .......................
-
-
-        for (int i = 0; i < dimension/2; i++) {
-            System.out.print(i+ "\t");
-        }
-        System.out.println();
-        for (int i = 0; i < dimension/2; i++) {
-            if(board[i].getPlayerID().compareTo(new UUID(0,0)) != 0)
-                System.out.print(board[i].getPlayerID().getLeastSignificantBits()+"\t");
-            else System.out.print("\t");
-        }
-        System.out.println();
-        for (int i = dimension/2; i < dimension; i++) {
-            System.out.print(i+ "\t");
-        }
-        System.out.println();
-        for (int i = dimension/2; i < dimension; i++) {
-            if(board[i].getPlayerID().compareTo(new UUID(0,0)) != 0)
-                System.out.print(board[i].getPlayerID().getLeastSignificantBits()+"\t");
-            else System.out.print("\t");
-        }
-        System.out.println();
-    }
-
-    public void movePlayerForward(int progress  , Player player){
-            int position = playerPosition.get(player);
-            int newPosition = position;
-
-
-            while (progress != 0){
-                newPosition = newPosition+1;
-                if(newPosition==board.length){
-                    compleatedTurns.put(player, compleatedTurns.get(player)+1);
-                    newPosition = 0;
-                }
-                if(board[newPosition].getPlayerID().compareTo(new UUID(0,0)) == 0)
-                    progress = progress -1;
-            }
-            board[position] =  new Player(new UUID(0,0));
-            board[newPosition] = player;
-            playerPosition.put(player, newPosition);
-    }
-
-    public void movePlayerBackwards(int progress, Player player) {
-        UUID playerId = player.getPlayerID();
-        int position = playerPosition.get(player);
-        int newPosition = position;
-
-        while (progress != 0){
-            newPosition = newPosition-1;
-            if(newPosition<0){
-                newPosition = board.length-1;
-                compleatedTurns.put(player, compleatedTurns.get(player)-1);
-            }
-            if(board[newPosition].getPlayerID().compareTo(new UUID(0,0)) == 0)
-                progress = progress -1;
-        }
-        board[position] =  new Player(new UUID(0,0));
-        board[newPosition] = player;
-        playerPosition.put(player, newPosition);
-    }
-
-
-    public List<Player> getPlayerOrder(){
-        List<Player> order = new ArrayList<Player>();
-        int i = board.length-1;
-        while(i!=-1){
-            if(board[i].getPlayerID().compareTo(new UUID(0,0)) != 0){
-                order.add(board[i]);
-            }
-            i--;
-        }
-        return order;
-    }
-
-    public void addPlayerMarker(Player player, int position) {
-            if(board.length == 18) {
-                if(position == 1){
-                    board[4] = player;
-                    playerPosition.put(player, 4);
-                    compleatedTurns.put(player, 0);
-                }
-                if(position == 2){
-                    board[2] = player;
-                    playerPosition.put(player, 2);
-                    compleatedTurns.put(player, 0);
-                }
-                if(position == 3){
-                    board[1] = player;
-                    playerPosition.put(player, 1);
-                    compleatedTurns.put(player, 0);
-                }
-                if(position == 4){
-                    board[0] = player;
-                    playerPosition.put(player, 0);
-                    compleatedTurns.put(player, 0);
-                }
-            }else {
-                if(position == 1){
-                    board[6] = player;
-                    playerPosition.put(player, 6);
-                    compleatedTurns.put(player, 0);
-                }
-                if(position == 2){
-                    board[3] = player;
-                    playerPosition.put(player, 3);
-                    compleatedTurns.put(player, 0);
-                }
-                if(position == 3){
-                    board[1] = player;
-                    playerPosition.put(player, 1);
-                    compleatedTurns.put(player, 0);
-                }
-                if(position == 4){
-                    board[0] = player;
-                    playerPosition.put(player, 0);
-                    compleatedTurns.put(player, 0);
-                }
-            }
-    }
-
-}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\n  <component name=\"MavenProjectsManager\">\n    <option name=\"originalFiles\">\n      <list>\n        <option value=\"$PROJECT_DIR$/pom.xml\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_22\" project-jdk-name=\"openjdk-23\" project-jdk-type=\"JavaSDK\">\n    <output url=\"file://$PROJECT_DIR$/out\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision d7f107aaab30e8811431f262415fca60e4aaac10)
+++ b/.idea/misc.xml	(date 1744371443468)
@@ -8,7 +8,7 @@
       </list>
     </option>
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_22" project-jdk-name="openjdk-23" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_23" default="true" project-jdk-name="openjdk-23" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
